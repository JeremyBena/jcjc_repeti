<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Résumé du projet – REPETI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">REPETI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./presentation.html" aria-current="page"> 
<span class="menu-text">Présentation générale du projet</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-axes-du-projet" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Axes du projet</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-axes-du-projet">    
        <li>
    <a class="dropdown-item" href="./axe1.html">
 <span class="dropdown-text">Axe 1 – Word-for-word and thematic repetition effects on truth judgments</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./axe2.html">
 <span class="dropdown-text">Axe 2 – Estimating memory representations in the truth effect</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./axe3.html">
 <span class="dropdown-text">Axe 3 – Testing interventions and their mechanisms to reduce the truth effect</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="./participer.html"> 
<span class="menu-text">Participer au projet</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./partenaires.html"> 
<span class="menu-text">Partenaires</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">À propos</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label=""><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://github.com/JeremyBena/jcjc_repeti">
            Code source
            </a>
          </li>
      </ul>
    </div>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Résumé du projet</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="vérité-perçue-des-informations-erronées-induite-par-la-répétition-repeti" class="level1">
<h1>Vérité perçue des informations (erronées) induite par la répétition – REPETI</h1>
<p><em>REpetition-induced PErceived Truth of (mis)Information (REPETI)</em></p>
<section id="résumé-tel-quil-apparaît-sur-le-site-de-lanr" class="level2">
<h2 class="anchored" data-anchor-id="résumé-tel-quil-apparaît-sur-le-site-de-lanr">Résumé tel qu’il apparaît sur le <a href="https://anr.fr/Projet-ANR-25-CE28-0842">site de l’ANR</a> :</h2>
<p>Avec l’accès massif à Internet et aux médias sociaux, l’exposition à grande échelle à des informations vraies, fausses, et trompeuses est devenue courante. Le projet REPETI (REpetition-induced PErceived Truth of [mis]Information) porte sur l’effet de la répétition sur la croyance à des informations, que ces informations soient problématiques ou non.</p>
<p>L’effet de vérité, soit l’augmentation de la vérité perçue d’une information par son exposition répétée, a été le plus souvent étudié avec des informations anodines répétées mot pour mot sous l’hypothèse que la répétition facilite le traitement des informations. S’écartant de cette approche classique, REPETI vise à mieux comprendre les représentations mnésiques qui sous-tendent les effets de la répétition mot pour mot et de la répétition thématique sur la vérité perçue d’informations, y compris de fausses informations qui peuvent avoir des implications sociétales significatives si elles sont crues (santé, démocratie) telles que des théories du complot.</p>
<p>À travers une série d’expériences sur trois axes de recherche, nous examinerons (Axe 1) si la répétition thématique influence différemment la vérité perçue comparée à la répétition mot pour mot, qu’il s’agisse d’informations anodines ou de théories du complot, (Axe 2) si des représentations mnésiques (verbatim, littérales ; gist, préservant le sens) contribuent à ces effet, en les modélisant grâce à une procédure expérimentale originale, et (Axe 3) l’efficacité d’interventions (avertissements ; incitations à la justesse) pour réduire l’effet de vérité, en particulier pour des théories du complot.</p>
<p>Il est attendu que REPETI ait des implications directes pour mieux comprendre quand et comment l’exposition répétée aux (fausses) informations contribue à la formation de croyances, et comment ce phénomène peut être atténué sur des informations considérées comme problématiques.</p>
<!--# Présentation du projet adaptée de la préproposition

Présentation uniquement en anglais. 

## Context, positioning, and objectives

Repetition-induced perceived truth (i.e., the truth effect) is a well-established phenomenon[1-3] typically explained by processing fluency[3-6]: repeatedly encountered information is easier to process than new information, and this fluency serves as a cue to truth. The truth effect is a memory phenomenon: Just as old items receive more “old” judgments than new items (i.e., recognition memory), repeated statements receive more “true” judgments than new statements. Recently, we proposed a memory-based account of the truth effect integrating several memory processes and representations underlying this effect[7,8]. Specifically, going beyond an explanation of the truth effect in terms of processing fluency, we suggested that literal (verbatim, capture details of the experience) and meaning-based (gist, capture the general theme) memory representations (based on the Fuzzy-Trace Theory[9-10]) could be involved in the truth effect. 

The truth effect is thought to have significant societal implications. Forming accurate beliefs is crucial for individual decisions (e.g., health[11]) and the functioning of institutions (importantly, democracy[12]). Yet, the Internet and social media, which are widely used to access information[13,14], disseminate information that is sometimes inaccurate or misleading[15-16]. As a result, individuals are regularly exposed to various information, some of which is false or misleading (e.g., conspiracy theories, fake news, rumors). Based on the truth effect, repeated exposure to misinformation could increase its perceived truth and influence decisions based on the formation of inadequate beliefs[17-18].

The truth effect is mainly studied with repeated word-for-word exposure to uncertain trivia statements of minimal importance[18-19]. First, such statements are non-emotional, non-social, and about benign states of affairs. Believing such statements is relatively harmless. Second, in real-life situations, repeated exposure to the same information may not be word-for-word; it could be thematic (e.g., paraphrases, preserving the meaning but not the exact details of previously encountered statements). As a result, little is currently known about (1) whether and how repeated exposure to (mis)information about consequential states of affairs (e.g., health-related; politics) increases beliefs[19], (2) whether this is the case when repeated exposure is thematic rather than word-for-word, and (3) which interventions could reduce the effect of repeated exposure (whether word-for-word or thematic) on beliefs, and why. REPETI sets out to examine these questions.

Recently, focusing on conspiracism (i.e., a belief that several actors have coordinated in secret to achieve an outcome and that their conspiracy is of public interest but not public knowledge[20]), we found that repeated word-for-word exposure increases the perceived truth of conspiracy theories[21]. We additionally found that perceived prior exposure is associated with conspiracism[22] in large-scale surveys. We also documented that (1) repeated word-for-word and thematic exposure to clickbait headlines (content designed to attract attention and clicks) increases perceived truth[23] and (2) truth judgments of highly implausible statements benefit from (word-for-word) repeated exposure[24]. 

REPETI’s general objective is to understand better the memory representations underlying the effects of word-for-word and thematic repetition on the perceived truth of information and misinformation that can have societal implications if believed. Such a project contributes to predicting better when the truth effect occurs and to identifying conditions under which it might be reduced or even eliminated. As a result, REPETI is aimed at addressing basic questions with possible applied implications.

## REPETI's research axes

REPETI comprises three research axes.

### Axis 1: Test the effects of word-for-word and thematic repetition on the perceived truth of trivia and conspiracy statements. 

We will test the effect of repetition (word-for-word repetition vs. thematic repetition vs. new statements) on truth judgments (assessed in a binary “true”/“false” truth judgment task) of adult participants on trivia and conspiracy statements (the basic procedure is an extension of the typical truth effect procedure[3,19]). Experiment 1 will use trivia statements, and Experiment 2 will use conspiracy statements. These experiments are replications and extensions of prior research we conducted on the effect of word-for-word repetition on trivia and conspiracy statements[21]. 

Based on conceptual fluency[25] and fuzzy-trace theory accounts of the truth effect[7,26], thematic repetition is enough to obtain a truth effect similar in size to the truth effect with word-for-word repetition. Under this perspective, retrieving the gist of a statement, but not verbatim representations, is key to the truth effect. However, past research does not allow clear conclusions regarding the effect of repetition’s format on the size of the truth effect because (1) they were not sufficiently powered to detect such differences and (2) contradictory results were obtained[27-30]. In addition, no such test was conducted with conspiracy statements. 

If retrieving the gist of statements contributes to the truth effect regardless of the retrieval of verbatim representations, we predict that the truth effect should be similar in magnitude for word-for-word and thematic repetition. However, if retrieving verbatim representations also contributes to the truth effect, the truth effect should be larger for word-for-word than thematic repetition (because items repeated identically are better cues to verbatim representations than items repeated thematically[31]). We will conduct experiments securing enough statistical power to detect a small effect of repetition’s format on the truth effect. In addition to frequentist analyses, we will use Bayesian analyses to quantify the support for the hypothesis of no effect against the hypothesis of a larger truth effect for word-for-word vs. thematic repetition. 

### Axis 2: Quantitatively estimate the contribution of memory representations to the truth effect with trivia and conspiracy statements. 

We will extend the experiments of Axis 1 to quantify the contribution of memory representations underlying the truth effect. At a single point in time, we will administer a truth judgment task and a conjoint recognition procedure[31-32]. Conjoint recognition tasks are similar to recognition tasks, except the test phase comprises “target” items (presented word-for-word in the exposure phase), “related” new items (thematically related to old items), and unrelated new items. Participants will judge whether each item is “target,” “related,” or “unrelated.” This task allows for quantifying the contribution of gist and verbatim representations and guessing biases to memory responses [31-32].

Based on a conditional judgment procedure recently developed[33] and an unpublished pilot experiment conducted with a Master’s student, Axis 2 aims at testing the associations between memory representations and the truth effect in procedures with trivia and conspiracy statements in which participants provide both “true”/“false” truth judgments and conjoint recognition judgments. Such a procedure allows obtaining estimates of gist retrieval, verbatim retrieval, and guessing biases that can be used to predict the truth effect with word-for-word and thematic repetition. If only gist representations contribute to the truth effect, we expect gist but not verbatim estimates to be positively correlated with the truth effect. If verbatim representations contribute to the truth effect, both gist and verbatim estimates should be positively associated with the truth effect. We will use a hierarchical latent-trait[34] simplified conjoint recognition model[31, 35] to obtain group-based and individual memory and guessing parameter estimates.

First, we will validate the new procedure with trivia and conspiracy statements. Because a direct memory task (conjoint recognition) is combined with an indirect memory task (truth judgments of repeated and new statements), we will need to document that participants can reliably report their memory and truth judgments. In a pilot experiment with this procedure, we found beyond-chance memory performance and more “true” responses for factually true than factually false statements. These results, obtained only with trivia statements, suggest that the procedure validly captures truth and conjoint memory judgments. We will use manipulations known to reduce memory (increasing the time interval between exposure and test – Experiments 3 and 4) and prior knowledge (Experiments 5 and 6) to test whether these manipulations influence memory and truth judgments, respectively. 

Once this procedure is validated, we will use it to test the substantive hypotheses presented above. To vary verbatim representations, we will manipulate the number of exposures in the exposure phase (1 vs. 5 exposures – Experiments 7 and 8). Increasing the number of exposures in the exposure phase should increase the retrieval of verbatim representations[31], which we could estimate with the measurement model. It will then be possible to test the association between estimates of verbatim retrieval and the truth effect. If verbatim representations contribute to the truth effect, increasing the number of exposures should increase the retrieval of verbatim representations (captured by the ‘Vt’ parameter) and the truth effect. 
Following the same logic, we will use another manipulation to vary gist representations: the number of related statements on a given topic (Experiments 9 and 10). Increasing the number of related statements should increase the retrieval of gist representations[35], which should increase the truth effect if these representations contribute to this effect. 
Additionally, we will use state trace analysis to test whether more than one latent process is required to explain the effect of repetition’s format on the truth effect[36-37]. 

### Axis 3: Test interventions to reduce the truth effect with conspiracy statements. 

Several interventions have been shown to reduce the truth effect, such as asking individuals to prevent the truth effect after being informed of its existence (warnings[38-40]) and presenting accuracy prompts in the exposure phase[41-44]. However, (1) these interventions were not tested in the context of conspiracy theories, (2) only word-for-word, not thematic, repeated exposure has been used, and (3) no insights into the underlying representations have been offered. As a result, the effectiveness of such interventions with problematic information (such as conspiracy statements) in realistic contexts (where repeated exposure can be thematic rather than word-for-word) and why they could be effective remains unknown.

We plan to test the effectiveness of warnings (Experiment 11) and accuracy prompts (Experiment 12) to reduce the truth effect with conspiracy statements. We will manipulate features of the procedure (warnings in the test phase: instructions to prevent the truth effect or control; accuracy prompts: task to judge statements’ truth or interest in the exposure phase). Using the procedure we propose to introduce in Axis 2 will allow testing whether these interventions are effective because they influence verbatim retrieval, gist retrieval, or guessing biases.  

By investigating cognitive antecedents of beliefs that can harm individuals and societies, REPETI aligns with the theme "Cognition, behavior, language" and contributes to the sustainable development goals of "quality education" and "peace, justice and strong institutions." In connection with the overarching goal of combating misinformation and its consequences, REPETI has the potential to advance knowledge on when and why repetition-induced belief formation occurs and how it can be mitigated when its effects may be detrimental. 

# Références

::: {#refs}
:::
-->
<!-- quarto render -->
<!-- git add docs -->
<!-- git commit -m "Publish site to docs/" -->
<!-- git push -->


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/github\.com\/JeremyBena\/jcjc_repeti");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>